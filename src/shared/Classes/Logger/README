# Roblox Logger Module with Knit

A comprehensive, production-ready logging system for Roblox built with **Clean Architecture** and **SOLID principles**. Designed to work seamlessly with the Knit framework.

## üèóÔ∏è Architecture Overview

This logger follows **Clean Architecture** principles with clear separation of concerns:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Presentation Layer                    ‚îÇ
‚îÇ  (LoggerService, LoggerController)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Use Case Layer                        ‚îÇ
‚îÇ           (LogUseCase)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Repository Layer                         ‚îÇ
‚îÇ        (LogRepository)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Data Layer (Writers, Filters, Entities)      ‚îÇ
‚îÇ  (ConsoleLogWriter, DataStoreLogWriter, etc)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìÅ File Structure

```
Logger/
‚îú‚îÄ‚îÄ Data Classes
‚îÇ   ‚îú‚îÄ‚îÄ LogLevel.lua          # Log severity levels enum
‚îÇ   ‚îî‚îÄ‚îÄ LogEntry.lua          # Log entry data model
‚îÇ
‚îú‚îÄ‚îÄ Interfaces
‚îÇ   ‚îú‚îÄ‚îÄ ILogWriter.lua        # Writer contract
‚îÇ   ‚îî‚îÄ‚îÄ ILogFilter.lua        # Filter contract
‚îÇ
‚îú‚îÄ‚îÄ Implementations
‚îÇ   ‚îú‚îÄ‚îÄ Writers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConsoleLogWriter.lua      # Output to console
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataStoreLogWriter.lua    # Persist to DataStore
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Filters
‚îÇ       ‚îú‚îÄ‚îÄ LevelLogFilter.lua        # Filter by log level
‚îÇ       ‚îî‚îÄ‚îÄ ContextLogFilter.lua      # Filter by context
‚îÇ
‚îú‚îÄ‚îÄ Repository
‚îÇ   ‚îî‚îÄ‚îÄ LogRepository.lua     # Data access layer
‚îÇ
‚îú‚îÄ‚îÄ Use Cases
‚îÇ   ‚îî‚îÄ‚îÄ LogUseCase.lua        # Business logic
‚îÇ
‚îú‚îÄ‚îÄ Knit Integration
‚îÇ   ‚îú‚îÄ‚îÄ LoggerService.lua     # Server-side service
‚îÇ   ‚îî‚îÄ‚îÄ LoggerController.lua  # Client-side controller
‚îÇ
‚îî‚îÄ‚îÄ Examples
    ‚îú‚îÄ‚îÄ ServerExample.lua
    ‚îî‚îÄ‚îÄ ClientExample.lua
```

## ‚ú® SOLID Principles Applied

### 1. **Single Responsibility Principle (SRP)**
- `LogEntry`: Only represents a log entry
- `LogRepository`: Only handles data access
- `LogUseCase`: Only contains business logic
- `ConsoleLogWriter`: Only writes to console
- Each class has one reason to change

### 2. **Open/Closed Principle (OCP)**
- Add new writers without modifying existing code
- Add new filters without modifying existing code
- Extensible through interfaces

### 3. **Liskov Substitution Principle (LSP)**
- All writers implement `ILogWriter` interface
- All filters implement `ILogFilter` interface
- Writers/filters are interchangeable

### 4. **Interface Segregation Principle (ISP)**
- Separate interfaces for writers and filters
- Clients only depend on methods they use

### 5. **Dependency Inversion Principle (DIP)**
- High-level modules (Service/Controller) depend on abstractions (Use Cases)
- Use Cases depend on Repository abstraction
- Implementations depend on interfaces

## üöÄ Installation

1. Place the Logger folder in `ReplicatedStorage`
2. Ensure Knit is installed in `ReplicatedStorage.Packages`

```
ReplicatedStorage/
‚îú‚îÄ‚îÄ Packages/
‚îÇ   ‚îî‚îÄ‚îÄ Knit/
‚îî‚îÄ‚îÄ Logger/
    ‚îî‚îÄ‚îÄ (all logger files)
```

## üìñ Usage

### Server-Side (LoggerService)

```lua
local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)

-- Start Knit
Knit.Start():andThen(function()
    local LoggerService = Knit.GetService("LoggerService")
    
    -- Basic logging
    LoggerService:Info("Server started", "System")
    LoggerService:Debug("Loading configuration...", "Config")
    LoggerService:Warn("Low memory detected", "System", { memory = "75%" })
    LoggerService:Error("Failed to load data", "DataService")
    
    -- With metadata
    LoggerService:Info("Player joined", "PlayerService", {
        userId = 12345,
        userName = "Player1"
    })
end)
```

### Client-Side (LoggerController)

```lua
local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)

-- Start Knit
Knit.Start():andThen(function()
    local LoggerController = Knit.GetController("LoggerController")
    
    -- Basic logging
    LoggerController:Info("UI loaded", "UI")
    LoggerController:Error("Failed to connect", "Network")
    
    -- Logs are sent to server based on threshold
    LoggerController:SetSendThreshold(LogLevel.WARN) -- Only send WARN+ to server
end)
```

## üîß Configuration

### Set Minimum Log Level

```lua
local LogLevel = require(game:GetService("ReplicatedStorage").Logger.LogLevel)
LoggerService:SetMinLogLevel(LogLevel.DEBUG) -- Show all logs
```

### Add Custom Writer

```lua
local MyCustomWriter = {}
function MyCustomWriter.new()
    return setmetatable({}, { __index = MyCustomWriter })
end

function MyCustomWriter:Write(logEntry)
    -- Custom logic here
end

function MyCustomWriter:Flush() end
function MyCustomWriter:Close() end

LoggerService:AddWriter(MyCustomWriter.new())
```

### Add Custom Filter

```lua
local MyFilter = {}
function MyFilter.new()
    return setmetatable({}, { __index = MyFilter })
end

function MyFilter:ShouldLog(logEntry)
    -- Return true to allow, false to filter out
    return logEntry.level >= LogLevel.WARN
end

LoggerService:AddFilter(MyFilter.new())
```

## üìä Query Logs

```lua
-- Get recent logs
local logs = LoggerService:GetRecentLogs(50)

-- Get logs by level
local errors = LoggerService:GetLogsByLevel(LogLevel.ERROR)

-- Get logs by context
local uiLogs = LoggerService:GetLogsByContext("UI")

-- Print logs
for _, log in ipairs(logs) do
    print(log:ToString())
end
```

## üéØ Features

- ‚úÖ **Multi-level logging** (DEBUG, INFO, WARN, ERROR, FATAL)
- ‚úÖ **Multiple output destinations** (Console, DataStore)
- ‚úÖ **Filtering system** (Level-based, Context-based)
- ‚úÖ **In-memory log history**
- ‚úÖ **Client-to-Server logging**
- ‚úÖ **Metadata support**
- ‚úÖ **Stack traces** (automatic)
- ‚úÖ **Timestamps** (automatic)
- ‚úÖ **Extensible architecture**
- ‚úÖ **Type-safe** (with Luau types)

## üè¢ Log Levels

```lua
LogLevel.DEBUG = 1  -- Detailed diagnostic information
LogLevel.INFO = 2   -- General informational messages
LogLevel.WARN = 3   -- Warning messages
LogLevel.ERROR = 4  -- Error messages
LogLevel.FATAL = 5  -- Critical errors
```

## üîå Extending the Logger

### Create a Custom Writer

```lua
-- HttpLogWriter.lua
local HttpService = game:GetService("HttpService")

local HttpLogWriter = {}
HttpLogWriter.__index = HttpLogWriter

function HttpLogWriter.new(endpoint)
    local self = setmetatable({}, HttpLogWriter)
    self.endpoint = endpoint
    return self
end

function HttpLogWriter:Write(logEntry)
    local data = {
        timestamp = logEntry.timestamp,
        level = logEntry.level,
        message = logEntry.message,
        context = logEntry.context
    }
    
    HttpService:PostAsync(self.endpoint, HttpService:JSONEncode(data))
end

function HttpLogWriter:Flush() end
function HttpLogWriter:Close() end

return HttpLogWriter
```

Then add it:
```lua
local HttpLogWriter = require(path.to.HttpLogWriter)
LoggerService:AddWriter(HttpLogWriter.new("https://your-endpoint.com/logs"))
```

## üß™ Testing

The architecture makes testing easy through dependency injection:

```lua
-- Mock writer for testing
local MockWriter = {}
function MockWriter.new()
    local self = { logs = {} }
    return setmetatable(self, { __index = MockWriter })
end

function MockWriter:Write(logEntry)
    table.insert(self.logs, logEntry)
end

-- Test
local repository = LogRepository.new()
local mockWriter = MockWriter.new()
repository:AddWriter(mockWriter)

local useCase = LogUseCase.new(repository)
useCase:Info("Test message")

assert(#mockWriter.logs == 1)
```

## üìù Best Practices

1. **Use appropriate log levels**
   - DEBUG: Development/diagnostic info
   - INFO: General application flow
   - WARN: Unexpected but handled situations
   - ERROR: Errors that need attention
   - FATAL: Critical errors

2. **Add context to logs**
   ```lua
   LoggerService:Info("Operation completed", "ModuleName")
   ```

3. **Include metadata for complex scenarios**
   ```lua
   LoggerService:Error("Database query failed", "Database", {
       query = "SELECT * FROM users",
       errorCode = 500
   })
   ```

4. **Use filters to reduce noise**
   - Set appropriate minimum log levels for production
   - Use context filters for specific debugging

## ü§ù Contributing

This module follows clean architecture principles. When adding features:

1. Create interfaces in the appropriate layer
2. Implement concrete classes
3. Follow SOLID principles
4. Update documentation

## üìÑ License

MIT License - Feel free to use in your projects!

## üôè Credits

Built with ‚ù§Ô∏è using Clean Architecture and SOLID principles